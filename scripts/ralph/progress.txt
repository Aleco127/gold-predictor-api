# Ralph Progress Log
Started: 2026-01-18T19:15:00.000Z
Feature: Gold Predictor v2 - Advanced Trading Features
Branch: ralph/gold-predictor-v2

## Codebase Patterns

### Project Structure
- FastAPI server in src/api/server.py
- ML models in src/models/
- Data connectors in src/data/
- Features in src/features/
- Config in src/config.py

### Key Files
- src/api/server.py - Main API endpoints
- src/data/capital_connector.py - Capital.com trading API
- src/models/ensemble.py - LSTM + XGBoost ensemble
- src/config.py - Settings and environment variables

### Testing
- Run with: python -m pytest tests/
- Typecheck with: python -m mypy src/

## Iteration Log

### Iteration 1 - US-009: Daily Loss Limit Protection
**Completed:** 2026-01-18

**Changes Made:**
- Created `src/trading/__init__.py` - Trading module init
- Created `src/trading/risk_manager.py` - Full RiskManager class with:
  - Daily P&L tracking
  - Trade recording
  - Daily loss limit enforcement (3% default)
  - Max daily trades limit (50 default)
  - Auto-reset at midnight UTC
- Updated `src/config.py` - Added risk management settings
- Updated `src/api/server.py` - Added risk management integration:
  - RiskManager initialized in lifespan
  - `/api/daily-stats` endpoint
  - `/api/risk-status` endpoint
  - `/api/record-pnl` endpoint
  - `/api/update-balance` endpoint
  - Risk check integrated into `/predict-and-trade`

**Patterns Discovered:**
- Use dataclasses for simple data containers (Trade, DailyStats)
- Use datetime.now(timezone.utc) for consistent UTC timestamps
- Global instances initialized in lifespan function
- Pydantic BaseModel for API response models

**Notes:**
- Risk manager blocks trading when daily loss >= daily_loss_limit_pct of account balance
- P&L should be recorded when positions close (not when opened)

### Iteration 2 - US-010: Volatility-Adjusted Position Sizing
**Completed:** 2026-01-18

**Changes Made:**
- Updated `src/config.py` - Added position sizing settings:
  - base_position_size, max_position_size, min_position_size
  - volatility_high_threshold (1.5x), volatility_low_threshold (0.7x)
  - volatility_lookback (20 periods)
- Updated `src/trading/risk_manager.py`:
  - Added PositionSizeResult dataclass
  - Added calculate_position_size() method using ATR ratio
  - Added get_position_sizing_config() method
- Updated `src/trading/__init__.py` - Exported PositionSizeResult
- Updated `src/api/server.py`:
  - Added PositionSizeResponse and PositionSizingConfigResponse models
  - Updated RiskManager init with position sizing params
  - Updated /predict-and-trade with use_volatility_sizing param
  - Added /api/position-sizing-config endpoint
  - Added /api/calculate-position-size endpoint

**Patterns Discovered:**
- ATR ratio = current_atr / average_atr(lookback)
- High volatility (>1.5x): adjustment_factor = 1/ratio (reduce size)
- Low volatility (<0.7x): adjustment_factor = min(1/ratio, 2.0) (increase size, cap at 2x)
- Always apply min/max limits after calculation

**Notes:**
- Position size is rounded to 2 decimal places for standard lot sizing
- Volatility sizing can be disabled with use_volatility_sizing=False

### Iteration 3 - US-007: Trailing Stop-Loss Implementation
**Completed:** 2026-01-18

**Changes Made:**
- Updated `src/config.py` - Added trailing stop settings:
  - trailing_stop_atr_multiplier (1.5x default)
  - trailing_activation_pips (10 pips default)
  - trailing_step_pips (5 pips minimum step)
- Created `src/trading/position_manager.py` - Full PositionManager class with:
  - TrackedPosition dataclass for position tracking state
  - TrailingStopUpdate dataclass for update recommendations
  - PositionDirection enum (BUY/SELL)
  - Position tracking with highest/lowest price history
  - Trailing stop calculation with activation threshold
  - Minimum step size enforcement
  - Take-profit level calculation
- Updated `src/trading/__init__.py` - Exported new classes
- Updated `src/data/capital_connector.py` - Added update_position() method for modifying SL/TP via API
- Updated `src/api/server.py`:
  - Added PositionManager initialization in lifespan
  - Added response models: TrackedPositionResponse, TrailingStopUpdateResponse, TrailingStopConfigResponse
  - Added request models: AddPositionRequest, UpdateTrailingStopRequest
  - `/api/trailing-stop-config` - Get trailing stop configuration
  - `/api/track-position` POST - Add position to tracker
  - `/api/track-position/{deal_id}` DELETE - Remove position from tracker
  - `/api/tracked-positions` - List all tracked positions
  - `/api/tracked-position/{deal_id}` - Get single position status
  - `/api/update-trailing-stop` - Calculate and apply trailing stop update
  - `/api/update-all-trailing-stops` - Batch update all positions

**Patterns Discovered:**
- Trailing stops track highest/lowest price since entry
- Activation requires profit >= activation_pips before trailing begins
- Stop moves only in favorable direction (up for BUY, down for SELL)
- Minimum step prevents excessive API calls for small movements
- Capital.com uses PUT to /positions/{deal_id} for updates

**Notes:**
- PositionManager is in-memory; positions should be re-added after restart
- update_position calls Capital.com API with stopLevel/profitLevel
- Trailing distance = current_atr * trailing_atr_multiplier

### Iteration 4 - US-008: Partial Take-Profit Levels
**Completed:** 2026-01-18

**Changes Made:**
- Updated `src/trading/position_manager.py`:
  - Added calculate_partial_close_size() method
  - Added record_partial_close() method with size tracking
  - Added move_stop_to_breakeven() method
  - Added process_tp_hit() method for processing TP actions
  - Added get_partial_tp_config() method
- Updated `src/api/server.py` - Added partial TP endpoints:
  - `/api/partial-tp-config` - Get TP configuration
  - `/api/calculate-tp-levels` - Calculate 3 TP levels from ATR
  - `/api/setup-position-with-tp` - Track position with auto TP levels
  - `/api/check-tp-levels/{deal_id}` - Check and execute partial closes
  - `/api/check-all-tp-levels` - Batch check all positions
  - `/api/move-to-breakeven/{deal_id}` - Move stop to entry price

**Patterns Discovered:**
- TP levels: 1x ATR (50%), 2x ATR (30%), 3x ATR (20%)
- After TP1 hit: auto-move stop to breakeven
- Partial close uses same close_position API with size parameter
- Track remaining position size after each partial close

**Notes:**
- Default config: 50%/30%/20% at 1x/2x/3x ATR
- Breakeven move only happens when it improves the stop (no backwards movement)
- TP level tracking persists until position is removed

### Iteration 5 - US-001: Economic Calendar API Integration
**Completed:** 2026-01-18

**Changes Made:**
- Created `src/data/economic_calendar.py` - Full EconomicCalendar class with:
  - ImpactLevel enum (LOW, MEDIUM, HIGH, HOLIDAY)
  - EconomicEvent dataclass with to_dict() serialization
  - Forex Factory HTML scraping with fallback source
  - High-impact keywords detection (Fed, CPI, NFP, GDP, etc.)
  - Caching with configurable refresh interval
  - Methods: fetch_events, get_upcoming_events, get_high_impact_events, is_near_high_impact_event
- Updated `requirements.txt` - Added beautifulsoup4>=4.12.0 and lxml>=4.9.0
- Updated `src/api/server.py`:
  - Added EconomicCalendar import and global instance
  - Added EconomicEventResponse and CalendarStatusResponse models
  - Initialize EconomicCalendar in lifespan with initial fetch
  - `/api/calendar` - Get events with filtering by hours_ahead and min_impact
  - `/api/calendar/high-impact` - Get only high-impact events
  - `/api/calendar/status` - Get calendar status and cache info
  - `/api/calendar/refresh` - Force refresh events from source

**Patterns Discovered:**
- Forex Factory uses table with class="calendar__table"
- Impact indicated by span class (high/red, medium/orange, low)
- Date rows vs event rows - track current_date as state
- Time format: 12-hour with am/pm or 24-hour
- Fallback source: generate known scheduled events (NFP first Friday, etc.)

**Notes:**
- Calendar fetches on startup and caches for 60 minutes
- Relevant currencies for gold: USD, EUR, GBP, JPY, CHF, CNY
- HIGH_IMPACT_KEYWORDS list boosts events even if not marked high
- is_near_high_impact_event() used for trading pause (US-002)

### Iteration 6 - US-002: Trading Pause During High-Impact Events
**Completed:** 2026-01-18

**Changes Made:**
- Updated `src/data/economic_calendar.py`:
  - Added NewsFilterResult dataclass with to_dict() serialization
  - Added NewsFilter class with configurable pause windows
  - Methods: check_trading_allowed, get_next_high_impact_event, get_config, get_status
- Updated `src/api/server.py`:
  - Added NewsFilter import and global instance
  - Initialize NewsFilter in lifespan (30 min before/after)
  - Updated /predict-and-trade endpoint:
    - Check news_filter before trading
    - Added news_paused and news_filter fields to response
    - Block trade if news_paused is true
    - Log when trade blocked by news filter
  - Added news filter endpoints:
    - `/api/news-filter/status` - Get full status with next event
    - `/api/news-filter/check` - Quick check if trading allowed
    - `/api/news-filter/config` - Get pause window configuration
- Updated `n8n-workflows/gold-prediction-trade.json`:
  - Added "News Paused?" IF check after "Trade Executed?"
  - Added "News Paused Alert" Telegram message
  - Updated connections to route through news pause check

**Patterns Discovered:**
- NewsFilter wraps EconomicCalendar for pause logic
- Pause window: minutes before event + minutes after event
- time_diff > 0 = event in future, < 0 = event in past
- n8n uses optional chaining (?.) for null-safe access

**Notes:**
- Default pause: 30 min before, 30 min after high-impact events
- Only HIGH impact level events trigger trading pause
- news_filter field only included in response when paused (saves bandwidth)
- n8n workflow shows event details in Telegram when paused

### Iteration 7 - US-003: News Sentiment API Integration
**Completed:** 2026-01-18

**Changes Made:**
- Created `src/data/news_fetcher.py` - Full NewsFetcher class with:
  - NewsArticle dataclass with to_dict() serialization
  - NewsAPI integration for fetching financial news
  - Gold keywords: gold, XAUUSD, precious metals, gold price, gold market
  - Macro keywords: Federal Reserve, Fed, interest rate, inflation, CPI, etc.
  - Async HTTP client with httpx for API calls
  - Caching with configurable duration (default 30 minutes)
  - Methods: fetch_news, get_recent_headlines, get_articles_by_keyword, get_headlines_for_sentiment
- Updated `src/config.py` - Added news API settings:
  - news_api_key: NewsAPI.org API key
  - news_cache_duration_minutes: Cache duration (default 30)
- Updated `.env.example` - Added NEWS_API_KEY and NEWS_CACHE_DURATION_MINUTES
- Updated `src/api/server.py`:
  - Added NewsFetcher import and global instance
  - Initialize NewsFetcher in lifespan (if API key configured)
  - `/api/news` - Get recent news with filtering by hours, count, keyword
  - `/api/news/headlines` - Get headlines formatted for sentiment analysis
  - `/api/news/status` - Get news fetcher status and cache info
  - `/api/news/refresh` - Force refresh news from API

**Patterns Discovered:**
- NewsAPI uses /v2/everything endpoint for historical search
- Query parameter uses "OR" for multiple keywords
- Date format: YYYY-MM-DDTHH:MM:SS for "from" parameter
- Free tier limited to last 24 hours of news
- httpx.AsyncClient for async HTTP requests with proper timeout

**Notes:**
- NEWS_API_KEY must be configured for news fetcher to work
- If no API key, fetcher is skipped in lifespan (graceful degradation)
- get_headlines_for_sentiment() returns simplified format for FinBERT
- Cache prevents hitting API rate limits (NewsAPI free: 100 requests/day)

### Iteration 8 - US-004: FinBERT Sentiment Analysis
**Completed:** 2026-01-18

**Changes Made:**
- Created `src/features/sentiment_analyzer.py` - Full SentimentAnalyzer class with:
  - SentimentScore dataclass (headline, sentiment, confidence, score)
  - AggregateSentiment dataclass (averages, counts, label)
  - FinBERT model integration using ProsusAI/finbert
  - Lazy loading to avoid slow startup (model loaded on first use)
  - Score caching with configurable duration (default 60 min)
  - Aggregate caching for performance
  - Methods: analyze_headline, analyze_headlines, calculate_aggregate, get_current_sentiment
  - Score mapping: positive=+1, negative=-1, neutral=0, scaled by confidence
  - Sentiment labels: BULLISH (>=0.15), BEARISH (<=-0.15), NEUTRAL
- Updated `requirements.txt` - Added transformers>=4.30.0 for FinBERT
- Updated `src/api/server.py`:
  - Added SentimentAnalyzer import and global instance
  - Initialize SentimentAnalyzer in lifespan with lazy_load=True
  - `/api/sentiment` - Get current aggregate sentiment from news
  - `/api/sentiment/analyze` - Analyze single headline
  - `/api/sentiment/analyze-batch` - Analyze multiple headlines
  - `/api/sentiment/status` - Get analyzer status and cache info
  - `/api/sentiment/clear-cache` - Clear sentiment cache

**Patterns Discovered:**
- Hugging Face transformers pipeline for sentiment-analysis
- ProsusAI/finbert returns labels: "positive", "negative", "neutral"
- Score = base_score (-1/0/+1) * confidence (0-1)
- Weighted average uses confidence as weight
- Lazy loading prevents slow startup (model ~400MB)
- MD5 hash for cache keys on headlines

**Notes:**
- First call to /api/sentiment will be slow (model download ~400MB)
- Subsequent calls use cached model and scores
- Aggregate sentiment combines with news fetcher (requires NEWS_API_KEY)
- BULLISH/BEARISH thresholds at +/-0.15 weighted score

### Iteration 9 - US-011: Trade History Database
**Completed:** 2026-01-18

**Changes Made:**
- Created `src/storage/trade_database.py` - Full TradeDatabase class with:
  - TradeOutcome enum (WIN, LOSS, BREAKEVEN, OPEN)
  - TradeRecord SQLAlchemy model with comprehensive fields:
    - Trade identification: deal_id, deal_reference, symbol
    - Trade details: direction, size, entry_price, exit_price, stop_loss, take_profit
    - P&L fields: pnl, pnl_pips, pnl_percent
    - Signal info: signal, confidence
    - Prediction tracking: predicted_price, predicted_direction, actual_direction, prediction_correct
    - Outcome and timestamps
    - Context: sentiment_score, volatility_regime, news_paused, notes
  - TradeFilter dataclass for query filtering
  - TradeSummary dataclass with win_rate, profit_factor, average metrics
  - Methods: log_trade_open, log_trade_close, get_trade, get_trades, get_summary, get_prediction_accuracy, get_open_trades, count_trades, get_status
- Updated `src/api/server.py`:
  - Added TradeDatabase import and global instance
  - Initialize TradeDatabase in lifespan (sqlite:///data/trades.db)
  - `/api/trades` - Get trade history with filtering (date range, direction, outcome, symbol, P&L range, signal)
  - `/api/trades/summary` - Get trade summary statistics
  - `/api/trades/accuracy` - Get prediction accuracy by signal type
  - `/api/trades/{deal_id}` - Get single trade details
  - `/api/trades/log-open` - Log trade opening
  - `/api/trades/log-close` - Log trade closure with outcome calculation
  - `/api/trades/open` - Get all open trades
  - `/api/trades/status` - Get database status

**Patterns Discovered:**
- SQLAlchemy's declarative_base() with sessionmaker pattern
- Context manager for session management (with self.SessionLocal() as session)
- TradeOutcome calculated from P&L with small threshold (0.01) for breakeven
- prediction_correct = predicted_direction == actual_direction
- Profit factor = gross_profit / abs(gross_loss)
- ISO format date parsing with Z -> +00:00 replacement for UTC

**Notes:**
- Database stored at data/trades.db (SQLite)
- TradeRecord uses deal_id as unique key (same as Capital.com deal ID)
- Outcome auto-calculated on trade close based on P&L
- Prediction accuracy tracks direction (UP/DOWN) not exact price
- Summary statistics exclude OPEN trades from win rate calculation

### Iteration 10 - US-012: Performance Metrics API
**Completed:** 2026-01-18

**Changes Made:**
- Created `src/monitoring/performance_tracker.py` - Full TradingPerformanceTracker class with:
  - DrawdownInfo dataclass with max/current drawdown, peak/trough equity
  - PerformanceMetrics dataclass with 25+ metrics including streaks
  - TradingPerformanceTracker class (named to avoid conflict with PerformanceTracker in drift_detector.py)
  - Sharpe ratio calculation (annualized with risk-free rate adjustment)
  - Sortino ratio calculation (downside deviation only)
  - Maximum drawdown tracking (peak-to-trough equity analysis)
  - Expectancy calculation: E = (Win% * Avg Win) + (Loss% * Avg Loss)
  - Profit factor, risk-reward ratio, consecutive win/loss streaks
  - Equity curve generation for charting
  - Period filtering: 7d, 30d, 90d, 365d, all
- Updated `src/monitoring/__init__.py` - Exported TradingPerformanceTracker, PerformanceMetrics, DrawdownInfo
- Updated `src/api/server.py`:
  - Added TradingPerformanceTracker import and global instance
  - Initialize TradingPerformanceTracker in lifespan with trade_db
  - `/api/performance` - Get full performance metrics with period filter
  - `/api/performance/drawdown` - Get detailed drawdown analysis
  - `/api/performance/equity-curve` - Get equity curve for charting
  - `/api/performance/summary` - Quick summary across 7d/30d/90d/all periods
  - `/api/performance/status` - Get tracker configuration and status

**Patterns Discovered:**
- Sharpe = (Mean Return - Risk Free Rate) / Std Dev * sqrt(periods_per_year)
- Sortino uses only downside (negative) returns for volatility
- Annualization factor = sqrt(trading_days_per_year) for ratios
- Max drawdown requires tracking running peak equity
- Named class TradingPerformanceTracker to avoid conflict with ModelPerformanceTracker

**Notes:**
- Risk-free rate default: 5% (US Treasury approximate)
- Trading days per year: 252 (standard for annualization)
- Profit factor capped at 999.99 when no losses (avoids infinity)
- Breakeven threshold: 0.01 (trades with |P&L| < 0.01 are breakeven)
- BULLISH/BEARISH thresholds at Â±0.15 weighted sentiment score

### Iteration 11 - US-013: Daily Performance Telegram Report
**Completed:** 2026-01-18

**Changes Made:**
- Updated `src/api/server.py`:
  - Added `/api/daily-report` endpoint with `format` parameter ("json" or "telegram")
  - Returns comprehensive daily report:
    - Today's trades summary (count, W/L, win rate, P&L, best/worst trade)
    - All-time metrics (total trades, win rate, profit factor, Sharpe, expectancy)
    - Equity status (initial balance, current equity, change, change %)
    - Drawdown metrics (max drawdown, current drawdown)
    - Risk status (trading allowed, daily P&L, trades remaining)
  - Added `_format_telegram_daily_report()` helper function for Telegram formatting
  - Beautiful emoji-rich formatting with sections and status indicators
- Created `n8n-workflows/daily-report.json`:
  - Schedule trigger: 22:00 UTC Monday-Friday (cron: "0 22 * * 1-5")
  - Trading day check with holiday exclusion (New Year, Christmas)
  - Conditional logic: sends full report if trades executed, simpler report if no trades
  - Uses Telegram Markdown formatting with parse_mode

**Patterns Discovered:**
- n8n cron expressions: "0 22 * * 1-5" = at minute 0, hour 22, any day, any month, Mon-Fri
- Telegram Markdown uses ** for bold, _ for italic
- Use conditional emojis based on P&L status (ðŸ“ˆ profitable, ðŸ“‰ loss, âž– breakeven)
- f-string format specifiers: {:+.2f} for signed 2 decimal, {:,.2f} for thousands separator

**Notes:**
- Report scheduled for 22:00 UTC (after most trading ends)
- If no trades today, sends simplified report with all-time stats only
- Major holidays (01-01, 12-25, 12-26) are skipped
- Telegram chatId: 6074722648 (same as other workflows)
- API uses format=telegram query param to get pre-formatted message

### Iteration 12 - US-005: Multi-Timeframe Data Fetching
**Completed:** 2026-01-18

**Changes Made:**
- Created `src/features/multi_timeframe.py`:
  - TimeframeData dataclass with:
    - Raw data (pandas DataFrame)
    - Calculated indicators DataFrame
    - Key indicator values: EMA 9/21/50, RSI, MACD, ATR, Bollinger Bands
    - Derived signals: trend_direction, ema_alignment, rsi_condition, price_vs_bb
    - to_dict() for JSON serialization
  - MultiTimeframeAnalysis dataclass with:
    - Symbol, timeframes dict, analysis_time
    - Confluence metrics placeholder (for US-006)
    - to_dict() for JSON serialization
  - MultiTimeframeAnalyzer class:
    - Configurable timeframes (default: M5, M15, H1, H4)
    - 200 bars per timeframe
    - Caching with timeframe-appropriate validity (M5: 2min, H1: 20min, H4: 1hr)
    - analyze() method fetches and analyzes all timeframes
    - _analyze_timeframe() fetches single timeframe, calculates indicators
    - _calculate_signals() derives trend direction, EMA alignment, RSI condition
    - get_summary() returns quick overview of all timeframes
    - get_status() returns analyzer configuration
- Updated `src/features/__init__.py`:
  - Exported MultiTimeframeAnalyzer, MultiTimeframeAnalysis, TimeframeData

**Patterns Discovered:**
- Cache validity varies by timeframe: faster timeframes expire sooner
- Days needed calculation: bars_needed / bars_per_day for each timeframe
- Trend direction based on EMA stacking: EMA_9 > EMA_21 > EMA_50 = BULLISH
- RSI conditions: >70 OVERBOUGHT, <30 OVERSOLD, else NEUTRAL
- Price vs Bollinger Bands: ABOVE_UPPER, BELOW_LOWER, or MIDDLE

**Notes:**
- Uses existing Capital.com connector's get_historical_data method
- Leverages TechnicalIndicators class for calculations
- Fallback to cached data on fetch errors
- Summary shows bullish/bearish/neutral counts across timeframes
- Overall trend = majority of timeframes agree

### Iteration 13 - US-006: Timeframe Confluence Scoring
**Completed:** 2026-01-18

**Changes Made:**
- Updated `src/features/multi_timeframe.py`:
  - Added `calculate_confluence()` method:
    - Counts trend directions across timeframes (BULLISH/BEARISH/NEUTRAL)
    - Counts RSI conditions (OVERBOUGHT/OVERSOLD)
    - Counts EMA alignments
    - Calculates weighted confluence score (60% trend, 30% EMA, 10% RSI factor)
    - RSI factor boosts/penalizes based on trend-RSI agreement
    - Returns overall_trend and trend_strength
  - Added `analyze_with_confluence()` convenience method
- Updated `src/models/ensemble.py`:
  - Added confluence fields to Prediction dataclass: confluence_score, confluence_trend, confluence_strength
  - Updated `to_dict()` to include confluence data in output
- Updated `src/api/server.py`:
  - Imported MultiTimeframeAnalyzer and related classes
  - Added global mtf_analyzer instance
  - Initialized mtf_analyzer in lifespan
  - `/api/timeframes` - Full multi-timeframe analysis with confluence
  - `/api/timeframes/confluence` - Quick confluence score with recommendation
  - `/api/timeframes/summary` - Cached summary without refetch
  - `/api/timeframes/{timeframe}` - Single timeframe details
  - `/api/timeframes/status` - Analyzer configuration status
  - Added `_get_confluence_recommendation()` helper for trading advice

**Patterns Discovered:**
- Confluence formula: (trend_agreement * 0.6) + (ema_agreement * 0.3) + (rsi_factor * 0.1)
- RSI factor bonus: +10% when RSI supports trend (oversold in bullish, overbought in bearish)
- RSI factor penalty: -10% when RSI contradicts trend (overbought in bullish, oversold in bearish)
- Recommendation thresholds: 80%+ strong, 60%+ moderate, 40%+ weak, <40% avoid

**Notes:**
- Higher confluence = higher confidence in trade direction
- 100% confluence means all timeframes agree on direction
- API returns both numerical score and text recommendation
- Confluence can be used to adjust position sizing or skip low-confidence trades
- Cached data used for summary endpoint for faster response

